# Ralph Run Feature Implementation Plan

**Date:** August 30, 2025
**Author:** Claude Code Feature Planner
**Type:** Feature Implementation Plan

## Executive Summary

This plan outlines the implementation of a continuous run feature for the Ralph CLI tool, enabling automated iterative execution of prompts with Claude Code. The run will integrate seamlessly with Ralph's existing React/Ink interactive UI architecture while providing graceful interrupt handling and status monitoring.

## Current State Analysis

### Ralph Architecture (As of August 2025)

- **CLI Framework:** Uses `meow` for argument parsing, renders React/Ink UI components
- **Entry Point:** `src/cli.tsx` handles command parsing and initialization
- **UI Component:** `src/app.tsx` provides interactive terminal interface using React/Ink
- **Build System:** TypeScript with ESM modules, Node.js >=22
- **Testing:** XO linting, Prettier formatting, AVA testing framework

### Key Findings

1. **Interactive-Only Mode:** Recent refactoring removed print/non-interactive modes in favor of unified interactive experience
2. **Prompt Handling:** Supports file paths (`-p path/to/file`) and direct text input
3. **React/Ink Architecture:** All UI rendered through Ink components with state management
4. **Configuration Support:** Prepared for `.ralph/` directory structure with settings, prompts, and specs
5. **Command Structure:** Basic commands (`init`, `config`, `update`) with extensible architecture

### Current Limitations

- No run or continuous execution capability
- No integration with external CLI tools (like `claude`)
- No output streaming or real-time status updates
- Single execution model only

## Reference Implementation Analysis

### Run.sh Pattern (from bash prototype)

```bash
#!/usr/bin/env bash
trap 'echo "exiting..."; exit 0' INT
while true; do
    cat prompt.md | claude -p --dangerously-skip-permissions --verbose --output-format stream-json | ./out.sh
done
```

**Key Elements from Bash prototype:**

- Signal handling for graceful interruption (`trap` for SIGINT)
- Infinite run with `while true`
- Pipe chain: `prompt file → claude CLI → output processor`
- Stream JSON output format for structured processing

### RepomirrorExample

- **Long-running unattended execution** (infinite development cycle)
- **Simple prompts** work better than complex ones (103 words vs 1500 words)
- **Cost tracking** (~$10.50/hour for Sonnet)
- **Self-termination behavior** when tasks complete
- **Emergent behaviors** like agents using `pkill` to stop themselves

## Proposed Architecture

### Core Components

#### 1. Run Engine (`src/run.tsx`)

- **Purpose:** Core run execution logic with state management
- **Responsibilities:**
  - Execute claude CLI commands with proper argument passing
  - Handle process lifecycle (spawn, monitor, terminate)
  - Manage run state (running, paused, stopped)
  - Provide abort/interrupt mechanisms

#### 2. Run UI Component (`src/components/RunDisplay.tsx`)

- **Purpose:** Real-time run status and output display
- **Responsibilities:**
  - Show current iteration count and timing
  - Display live claude output (with truncation options)
  - Provide interactive controls (pause, stop, view full output)

#### 3. Output Processor (`src/output.tsx`)

- **Purpose:** Handle and format claude CLI output
- **Responsibilities:**
  - Parse stream JSON output from claude
  - Format for terminal display with React/Ink

#### 4. Configuration Extension

- **Purpose:** Run-specific settings and preferences
- **Responsibilities:**
  - Run interval configuration
  - Output formatting preferences
  - Auto-stop conditions

### Integration Points

#### CLI Command Structure

```bash
# New run commands
ralph [prompt-file]        # Start continuous run
ralph -p "prompt text"     # Start with inline prompt
```

#### Modified App.tsx Integration

- **Run Mode Detection:** Check for run-related commands
- **Conditional Rendering:** Show RunDisplay component when running
- **State Management:** Maintain state across UI updates
- **Keyboard Shortcuts:** Ctrl+C for graceful exit, Ctrl+P for pause/resume

## Implementation Roadmap

### Phase 1: Foundation (Week 1)

**Objective:** Basic run infrastructure and CLI integration

1. **Add Command Parsing**

   - Add run-specific flags and options
   - Update help text and command validation

2. **Create Run Engine**

   - Implement `src/run.tsx` with basic run logic
   - Add claude CLI subprocess management
   - Implement signal handling for graceful shutdown

3. **Update App Component**
   - Add run mode detection
   - Create basic run status display
   - Implement keyboard interrupt handling

### Phase 2: Output Processing (Week 2)

**Objective:** Stream processing and formatted output display

1. **Stream JSON Parser**

   - Create output processor for claude stream-json format
   - Implement real-time parsing and formatting
   - Add error handling for malformed JSON

2. **Run Display Component**

   - Build React/Ink component for run status
   - Add iteration counter and timing display
   - Implement basic output streaming view

3. **Output Formatting**
   - Adapt patterns to format @docs/claude_tool_schema.jsonl with React/Ink
   - Add syntax highlighting for code blocks
   - Implement truncation with expansion options

### Phase 3: Enhanced Features (Week 3)

**Objective:** Statistics, configuration, and user experience improvements

1. **Configuration System**

   - Extend `.ralph/settings.toml` for run settings
   - Add configuration validation
   - Implement runtime configuration updates

### Phase 4: Polish and Testing (Week 4)

**Objective:** Robustness, testing, and documentation

1. **Error Handling**

   - Comprehensive error recovery
   - Network failure handling
   - Process crash recovery

2. **Testing Suite**

   - Unit tests for run engine
   - Integration tests for CLI commands
   - Mock claude CLI for testing

3. **Documentation**
   - Update README with run commands
   - Add usage examples
   - Document configuration options

## Technical Specifications

### Dependencies

```json
{
	"dependencies": {
		"ink": "^4.0.0",
		"react": "^18.0.0",
		"meow": "^12.0.0",
		"execa": "^8.0.0", // For subprocess management
		"chalk": "^5.0.0", // For terminal colors
		"ms": "^2.1.3" // For time formatting
	},
	"devDependencies": {
		"sinon": "^15.0.0", // For mocking in tests
		"@types/ms": "^0.7.0"
	}
}
```

### File Structure

```
src/
  cli.tsx                    # Enhanced with run commands
  app.tsx                    # Updated with run mode support
  run.tsx                   # Core run engine
  output.tsx                 # Output processing logic
  components/
    RunDisplay.tsx          # Run status and output UI
    StatisticsDisplay.tsx    # Usage statistics component
  types/
    run.ts                  # Run-related TypeScript types
  utils/
    claude.ts                # Claude CLI interaction utilities
    config.ts                # Configuration management
```

### Configuration Schema

```toml
# .ralph/settings.toml
[run]
interval_ms = 1000                    # Minimum time between iterations
auto_stop_after_errors = 5            # Stop after N consecutive errors
max_cost_usd = 50.0                   # Stop when cost limit reached
output_format = "formatted"           # "formatted" | "raw" | "minimal"
show_statistics = true                # Show stats in UI
truncate_output = true                # Truncate long outputs
max_output_lines = 50                 # Lines to show before truncation

[claude]
flags = [                             # Default claude CLI flags
  "--dangerously-skip-permissions",
  "--verbose",
  "--output-format",
  "stream-json"
]
model = "claude-3-5-sonnet-20241022"   # Default model
timeout_ms = 300000                   # 5-minute timeout per iteration
```

### Data Flow

```
User Input → CLI Parser → Run Engine → Claude CLI → Output Processor → Ink UI
     ↑                                                                      ↓
     └── Keyboard Controls ←── React Event Handler ←── Run Display Component
```

## Risk Assessment and Mitigation

### High Priority Risks

1. **Process Management Complexity**

   - **Risk:** Subprocess lifecycle management in Node.js
   - **Mitigation:** Use battle-tested `execa` library, comprehensive error handling

2. **Memory Leaks in Long-Running Runs**
   - **Risk:** React components and subprocess outputs consuming memory
   - **Mitigation:** Output buffer limits, component cleanup, regular garbage collection

### Medium Priority Risks

1. **Signal Handling Complexity**

   - **Risk:** Inconsistent interrupt behavior across platforms
   - **Mitigation:** Platform-specific testing, graceful fallbacks

2. **Output Formatting Performance**
   - **Risk:** Real-time JSON parsing and React rendering performance
   - **Mitigation:** Streaming optimization, virtual scrolling for large outputs

## Testing Strategy

### Unit Testing

- **Run Engine:** Test start/stop functionality with mocked claude CLI
- **Output Processor:** Test JSON parsing with sample stream data
- **Configuration:** Test settings validation and loading

### Integration Testing

- **CLI Commands:** Test all run subcommands end-to-end
- **Process Management:** Test subprocess lifecycle with actual claude CLI
- **UI Components:** Test React/Ink rendering with various data states

### Manual Testing Scenarios

1. **Basic Run:** Start run with simple prompt, verify execution
2. **Interrupt Handling:** Test Ctrl+C during execution
3. **Error Recovery:** Test behavior with network failures and bad prompts
4. **Configuration:** Test various settings combinations

### Performance Testing

- **Memory Usage:** Monitor memory consumption during extended runs
- **CPU Usage:** Verify reasonable resource utilization
- **Output Latency:** Measure time from claude output to UI update

## Success Metrics

### Functional Requirements

- ✅ Successfully execute continuous runs with claude CLI
- ✅ Graceful interrupt handling (Ctrl+C)
- ✅ Real-time output display with formatting
- ✅ Configuration system for customization
- ✅ Error recovery and robust operation

### Performance Requirements

- **Memory:** <100MB baseline, <500MB during intensive operations
- **Startup Time:** <5 seconds from command to first execution
- **Output Latency:** <100ms from claude output to UI display

### User Experience Requirements

- **Intuitive Commands:** Clear, self-documenting CLI interface
- **Visual Feedback:** Rich terminal UI with status indicators
- **Responsive Controls:** Immediate response to user input
- **Helpful Errors:** Clear error messages with resolution suggestions

## Future Enhancements

### Planned Improvements (Post-V1)

1. **Multiple Run Management:** Run multiple runs simultaneously
2. **Web Dashboard:** Browser-based monitoring and control interface
3. **Notification System:** Desktop/email notifications for completion/errors
4. **Template System:** Predefined run configurations for common tasks
5. **Log Management:** Structured logging with rotation and analysis
6. **Plugin Architecture:** Extensible system for custom output processors

### Potential Integrations (Not to be explored now)

- **GitHub Actions:** Automated run execution in CI/CD
- **Docker Support:** Containerized run execution
- **Cloud Deployment:** Run runs on cloud instances
- **Monitoring Tools:** Integration with observability platforms

## Conclusion

The Ralph Run feature will transform Ralph from a single-execution tool into a powerful continuous automation platform. By building on the solid foundation of React/Ink and following patterns from successful implementations like run.sh and RepoMirror, we can deliver a robust, user-friendly run system that integrates seamlessly with the existing architecture.

The phased implementation approach ensures incremental delivery of value while maintaining code quality and user experience standards. The comprehensive testing strategy and risk mitigation plans provide confidence in the system's reliability for production use.

This feature positions Ralph as a leading tool for AI-powered continuous development workflows, enabling users to achieve the kind of breakthrough results demonstrated in the RepomirrorHQ overnight development sessions.
